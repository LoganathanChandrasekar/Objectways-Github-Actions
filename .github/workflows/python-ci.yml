name: Python CI/CD

on:
  workflow_call:
    inputs:
      python-version: { type: string, default: '3.12' }
      working-directory: { type: string, default: 'backend' }
      aws-region: { type: string, required: true }
      deploy-runner: { type: string, default: 'self-hosted' }
      s3-bucket: { type: string, required: true }
      deploy-path: { type: string, required: true } # BASE directory
      env-source-path: { type: string, required: false }
      debug_enabled: { type: boolean, default: false }
      python-entry-point: { type: string, required: false }
      serviceName: { type: string, required: true }
    secrets:
      aws-role-arn: { required: true }

permissions:
  contents: read
  id-token: write

jobs:
  build-test:
    runs-on: ${{ inputs.deploy-runner }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Set up Python
        run: |
          python3 -m venv .venv
          source .venv/bin/activate
          pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install safety ruff pytest
        working-directory: ${{ inputs.working-directory }}

      - name: Dependency Audit (Safety)
        run: |
          source .venv/bin/activate
          safety check -r requirements.txt
        continue-on-error: true
        working-directory: ${{ inputs.working-directory }}

      - name: Code Quality (Ruff)
        run: |
          source .venv/bin/activate
          ruff check .
        continue-on-error: true
        working-directory: ${{ inputs.working-directory }}

      - name: Prepare Artifact
        run: |
          mkdir -p deploy-package
          rsync -a ./ deploy-package/ --exclude .git --exclude .venv --exclude __pycache__
          cd deploy-package
          tar -czf ../release-${{ github.sha }}.tar.gz .
        working-directory: ${{ inputs.working-directory }}

      - name: AWS Auth
        if: ${{ !env.ACT }}
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: ${{ secrets.aws-role-arn }}
          aws-region: ${{ inputs.aws-region }}

      - name: Upload to S3
        if: ${{ !env.ACT }}
        run: |
          aws s3 cp release-${{ github.sha }}.tar.gz s3://${{ inputs.s3-bucket }}/backend/releases/release-${{ github.sha }}.tar.gz
        working-directory: ${{ inputs.working-directory }}

  deploy:
    needs: build-test
    runs-on: ${{ inputs.deploy-runner }}
    steps:
      - name: AWS Auth
        if: ${{ !env.ACT }}
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: ${{ secrets.aws-role-arn }}
          aws-region: ${{ inputs.aws-region }}

      - name: Atomic Deployment
        if: ${{ !env.ACT }}
        shell: bash
        run: |
          BASE_DIR=$(echo "${{ inputs.deploy-path }}" | xargs)
          RELEASE_ID=$(date +%Y%m%d%H%M%S)-${{ github.sha }}
          RELEASES_DIR="$BASE_DIR/releases"
          NEW_RELEASE_DIR="$RELEASES_DIR/$RELEASE_ID"
          SERVICE_NAME="${{ inputs.serviceName }}"
          ENV_SOURCE=$(echo "${{ inputs.env-source-path }}" | xargs)
          CURRENT_LINK="$BASE_DIR/current"

          echo "Deploying Backend Release: $RELEASE_ID"
          mkdir -p "$RELEASES_DIR"

          # 1. SMART MIGRATION SAFEGUARD
          if [ -d "$CURRENT_LINK" ] && [ ! -L "$CURRENT_LINK" ]; then
            echo "MIGRATION: Existing directory found at $CURRENT_LINK. Moving to releases/legacy_backup."
            mv "$CURRENT_LINK" "$RELEASES_DIR/legacy_backup_$(date +%Y%m%d%H%M%S)"
          fi
          
          mkdir -p "$NEW_RELEASE_DIR"
          
          # 2. Fetch & Extract
          aws s3 cp s3://${{ inputs.s3-bucket }}/backend/releases/release-${{ github.sha }}.tar.gz artifact.tar.gz
          tar -xzf artifact.tar.gz -C "$NEW_RELEASE_DIR"
          rm artifact.tar.gz

          # 3. Setup production venv in the new release
          cd "$NEW_RELEASE_DIR"
          python3 -m venv .venv
          source .venv/bin/activate
          pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

          # 4. Restore .env if provided
          if [ -f "$ENV_SOURCE" ]; then
            cp "$ENV_SOURCE" "$NEW_RELEASE_DIR/.env"
            echo "Env restored from $ENV_SOURCE"
          fi

          # 5. ATOMIC SWITCH
          ln -sfn "$NEW_RELEASE_DIR" "$CURRENT_LINK"

          # 4. Restart Service
          echo "Restarting service: $SERVICE_NAME"
          if systemctl list-units --full -all | grep -Fq "$SERVICE_NAME"; then
             sudo systemctl restart "$SERVICE_NAME"
          else
             echo "Warning: Service $SERVICE_NAME not found. Setup manual systemd pointer to '$BASE_DIR/current'."
          fi

          # 5. Release Retention
          cd "$RELEASES_DIR" && ls -t | tail -n +6 | xargs rm -rf -- || true
          
          echo "Backend Deployment Successful."
